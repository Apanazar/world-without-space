# Пути к математическому доказательству

#### **Аксиома 1: Представление объектов через распределения вероятностей**

Каждый объект \( O \) в мире представлен как квантовый объект с распределением вероятностей по координатам в дискретной сетке \( W \times H \).

\[
O = \left\{ \text{Name}, \, \{(x, y) \mapsto P(x, y)\}, \, \text{IsCollapsed}, \, \text{FinalCoord} \right\}
\]

где:
- Name — строковый идентификатор объекта.
- \( \{(x, y) \mapsto P(x, y)\} \) — распределение вероятностей по координатам,
- \( \text{IsCollapsed} \) — булева переменная, указывающая, произошло ли коллапс волновой функции,
- \( \text{FinalCoord} \) — финальная координата после коллапса.

#### **Аксиома 2: Нормировка распределения вероятностей**

Для любого квантового объекта сумма вероятностей всех возможных координат равна 1.

\[
\sum_{x=0}^{W-1} \sum_{y=0}^{H-1} P(x, y) = 1
\]

#### **Аксиома 3: Коллапс волновой функции**

Коллапс волновой функции происходит случайным образом в соответствии с распределением вероятностей \( P(x, y) \). После коллапса объект фиксируется в одной координате \( (x, y) \), и его состояние становится определённым.

#### **Аксиома 4: Взаимодействие через совпадение координат**

Взаимодействие между двумя объектами происходит только тогда, когда их координаты совпадают. При взаимодействии оба объекта коллапсируют свои волновые функции в совпадающей координате.

### Связь модели с существующими теориями

#### **Квантовая механика**

Наша модель напоминает основные принципы квантовой механики, где объекты находятся в суперпозиции состояний до момента измерения (коллапса волновой функции). В традиционной квантовой механике состояние системы описывается волновой функцией, и при измерении система переходит в одно из возможных состояний с определённой вероятностью.

**Соответствие:**
- **Суперпозиция:** Объекты находятся в суперпозиции всех возможных координат.
- **Коллапс:** При измерении (взаимодействии) объект фиксируется в одной координате.
- **Вероятностное распределение:** Распределение вероятностей соответствует вероятностному распределению состояний в квантовой механике.

#### **Теория вероятностей**

Модель опирается на распределения вероятностей для описания состояния объектов. Методы нормировки и случайного выбора координат при коллапсе основаны на фундаментальных принципах теории вероятностей.

#### **Информационная теория вселенной**

Наша модель рассматривает вселенную как информационную структуру, где состояния объектов определяются распределениями вероятностей. Это перекликается с идеями информационной теории вселенной, где информация является фундаментальной сущностью.

#### **Квантовая гравитация и сетчатые модели**

Дискретная сетка координат без метрики напоминает подходы в квантовой гравитации, где пространство может быть представлено как дискретная структура из квантов пространства.

### Математические утверждения и доказательства

На данном этапе необходимо сформулировать конкретные математические утверждения, которые поддерживают ключевые свойства нашей модели, и предоставить их доказательства.

#### **Утверждение 1: Отсутствие зависимости взаимодействий от расстояния**

Взаимодействие между двумя объектами происходит исключительно при совпадении их координат, что приводит к отсутствию зависимости от расстояния между ними.

**Формулировка:**

Пусть \( O_1 \) и \( O_2 \) — два квантовых объекта с распределениями вероятностей \( P_1(x, y) \) и \( P_2(x, y) \) соответственно. Тогда взаимодействие \( I(O_1, O_2) \) определяется как:

\[
I(O_1, O_2) = \sum_{x=0}^{W-1} \sum_{y=0}^{H-1} P_1(x, y) \cdot P_2(x, y)
\]

При этом взаимодействие происходит только при совпадении координат \( (x, y) \).

**Доказательство:**

Взаимодействие определяется как пересечение распределений вероятностей объектов в каждой точке \( (x, y) \). Поскольку взаимодействие происходит только при совпадении координат, расстояние между объектами \( d(O_1, O_2) \) не влияет на вероятность взаимодействия. Таким образом, взаимодействие зависит только от наличия общих координат с ненулевыми вероятностями, а не от расстояния между объектами.

#### **Утверждение 2: Коллапс независимо от временных параметров**

Коллапс волновой функции объектов происходит независимо от каких-либо временных параметров, что подразумевает отсутствие фундаментального понятия времени в модели.

**Формулировка:**

Процесс коллапса объекта \( O \) определяется только его текущим распределением вероятностей \( P(x, y) \) и не зависит от временных переменных.

**Доказательство:**

В реализации модели метод `Collapse` не учитывает время или историю состояний объекта. Коллапс происходит мгновенно при вызове метода на основе текущего распределения вероятностей. Таким образом, состояние объекта после коллапса зависит только от текущего распределения, а не от временных параметров или предыдущих состояний.

#### **Утверждение 3: Сохранение нормировки распределений после взаимодействия**

После взаимодействия двух объектов их распределения вероятностей сохраняют нормировку.

**Формулировка:**

Пусть \( O_1 \) и \( O_2 \) взаимодействуют и их новые распределения \( P'_1(x, y) \) и \( P'_2(x, y) \) определяются как:

\[
P'_1(x, y) = P_1(x, y) \cdot P_2(x, y)
\]
\[
P'_2(x, y) = P_1(x, y) \cdot P_2(x, y)
\]

Тогда \( \sum_{x,y} P'_1(x, y) = \sum_{x,y} P'_2(x, y) = \frac{1}{Z} \), где \( Z \) — нормировочная константа.

**Доказательство:**

Поскольку \( P'_1(x, y) = P'_2(x, y) = P_1(x, y) \cdot P_2(x, y) \), нормировка выполняется следующим образом:

\[
\sum_{x,y} P'_1(x, y) = \sum_{x,y} P_1(x, y) \cdot P_2(x, y) = Z
\]

После нормировки:

\[
P''_1(x, y) = \frac{P'_1(x, y)}{Z} = \frac{P_1(x, y) \cdot P_2(x, y)}{Z}
\]
\[
P''_2(x, y) = \frac{P'_2(x, y)}{Z} = \frac{P_1(x, y) \cdot P_2(x, y)}{Z}
\]

Тогда:

\[
\sum_{x,y} P''_1(x, y) = \sum_{x,y} P''_2(x, y) = 1
\]

Таким образом, после взаимодействия распределения сохраняют нормировку.

### Исследование внутренних свойств модели


#### **Симметрии**

**Симметрия относительно координатной сетки:**

Модель обладает симметрией относительно трансляций и отражений координатной сетки. Поскольку распределения вероятностей определяются независимо для каждой точки, перемещение всей сетки или её отражение не изменяет внутреннюю логику взаимодействий.

**Формальное выражение:**

Пусть \( T \) — трансляция на \( (\Delta x, \Delta y) \), тогда для любого объекта \( O \) после трансляции:

\[
P_T(x, y) = P(x - \Delta x, y - \Delta y)
\]

Логика взаимодействий остается неизменной, так как взаимодействие зависит только от совпадения координат.

#### **Инварианты**

**Инвариантность нормировки:**

Нормировка распределений вероятностей сохраняется при любых взаимодействиях и коллапсах, что является инвариантом модели.

**Формальное выражение:**

Для любого взаимодействия \( I(O_1, O_2) \), если \( \sum_{x,y} P'_1(x, y) = \sum_{x,y} P'_2(x, y) = \frac{1}{Z} \), то после нормировки:

\[
\sum_{x,y} P''_1(x, y) = \sum_{x,y} P''_2(x, y) = 1
\]

#### **Устойчивость системы**

**Устойчивость к повторным взаимодействиям:**

После коллапса объект фиксируется в одной координате, и повторные взаимодействия не изменяют его состояние, что обеспечивает устойчивость системы.

**Формальное выражение:**

Пусть \( O \) — объект с \( \text{IsCollapsed} = \text{true} \), тогда любое последующее взаимодействие не изменяет \( \text{FinalCoord} \).

\[
\forall I, \, O.\text{IsCollapsed} = \text{true} \Rightarrow O.\text{FinalCoord} \text{ неизменен}
\]

### Симуляции и эмпирические проверки

#### **Проверка нормировки распределений после взаимодействий**

**Цель:**

Убедиться, что после взаимодействия распределения объектов сохраняют нормировку.

**Метод:**

1. Создать два объекта с известными распределениями вероятностей.
2. Выполнить взаимодействие между ними.
3. Проверить, что суммы новых распределений равны 1.

**Реализация:**

```go
func testNormalizationAfterInteraction() {
    world := NewWorld(5, 5)
    
    // Объект 1: Распределение в точках (0,0) и (1,1)
    obj1Dist := map[[2]int]float64{
        {0, 0}: 1.0,
        {1, 1}: 1.0,
    }
    obj1 := NewQuantumObject("Obj1", obj1Dist)
    
    // Объект 2: Распределение в точках (0,0) и (2,2)
    obj2Dist := map[[2]int]float64{
        {0, 0}: 1.0,
        {2, 2}: 1.0,
    }
    obj2 := NewQuantumObject("Obj2", obj2Dist)
    
    world.AddQuantumObject(obj1)
    world.AddQuantumObject(obj2)
    
    world.MeasureInteraction(obj1, obj2)
    
    // Проверка нормировки
    total1 := 0.0
    for _, w := range obj1.CoordDist {
        total1 += w
    }
    total2 := 0.0
    for _, w := range obj2.CoordDist {
        total2 += w
    }
    
    fmt.Printf("Total Obj1 after interaction: %f\n", total1)
    fmt.Printf("Total Obj2 after interaction: %f\n", total2)
}

```

**Ожидаемый результат:**

После взаимодействия только точка (0,0) остаётся общей для обоих объектов. Распределение должно быть нормировано на эту точку.

```
Total Obj1 after interaction: 1.0
Total Obj2 after interaction: 1.0
```

**Итоговый результат**
```
Total Obj1 after interaction: 1.000000
Total Obj2 after interaction: 1.000000
```

#### **Проверка отсутствия зависимости взаимодействий от расстояния**

**Цель:**

Убедиться, что взаимодействия происходят только при совпадении координат, независимо от расстояния между ними.

**Метод:**

1. Создать два объекта с распределениями, расположенными на различном расстоянии друг от друга.
2. Выполнить взаимодействие и убедиться, что взаимодействие не происходит (коллапс не происходит).
3. Создать два объекта с совпадающими координатами и убедиться, что взаимодействие происходит.

**Реализация:**

```go
func testInteractionDependenceOnDistance() {
    world := NewWorld(5, 5)
    
    // Объект 1: Распределение в точке (0,0)
    obj1Dist := map[[2]int]float64{
        {0, 0}: 1.0,
    }
    obj1 := NewQuantumObject("Obj1", obj1Dist)
    
    // Объект 2: Распределение в точке (4,4) — расстояние 8 от (0,0)
    obj2Dist := map[[2]int]float64{
        {4, 4}: 1.0,
    }
    obj2 := NewQuantumObject("Obj2", obj2Dist)
    
    world.AddQuantumObject(obj1)
    world.AddQuantumObject(obj2)
    
    world.MeasureInteraction(obj1, obj2)
    
    // Проверка коллапса
    fmt.Println(obj1)
    fmt.Println(obj2)
    
    // Теперь объекты на одной координате
    obj3Dist := map[[2]int]float64{
        {2, 2}: 1.0,
    }
    obj4Dist := map[[2]int]float64{
        {2, 2}: 1.0,
    }
    obj3 := NewQuantumObject("Obj3", obj3Dist)
    obj4 := NewQuantumObject("Obj4", obj4Dist)
    
    world.AddQuantumObject(obj3)
    world.AddQuantumObject(obj4)
    
    world.MeasureInteraction(obj3, obj4)
    
    fmt.Println(obj3)
    fmt.Println(obj4)
}

```

**Ожидаемый результат:**

- В первом случае объекты находятся на разных координатах, поэтому коллапс не происходит.
- Во втором случае объекты находятся на одной координате, поэтому происходит коллапс.

```
<Obj1 collapsed at (0, 0)>
<Obj2 collapsed at (4, 4)>
<Obj3 collapsed at (2, 2)>
<Obj4 collapsed at (2, 2)>
```

**Итоговый результат**
```
<Obj1 in superposition (uncollapsed)>
<Obj2 in superposition (uncollapsed)>
<Obj3 collapsed at (2, 2)>
<Obj4 collapsed at (2, 2)>
```

#### **Проверка устойчивости системы при множественных взаимодействиях**

**Цель:**

Проверить, что после коллапса объекты остаются в фиксированных состояниях и не изменяются при последующих взаимодействиях.

**Метод:**

1. Создать объект и несколько других объектов для взаимодействий.
2. После первого взаимодействия объект коллапсирует.
3. Выполнить дополнительные взаимодействия и убедиться, что коллапсированный объект не изменяется.

**Реализация:**

```go
func testSystemStability() {
    world := NewWorld(5, 5)
    
    // Объект 1: Распределение в точке (1,1)
    obj1Dist := map[[2]int]float64{
        {1, 1}: 1.0,
    }
    obj1 := NewQuantumObject("Obj1", obj1Dist)
    
    // Объект 2: Распределение в точке (1,1)
    obj2Dist := map[[2]int]float64{
        {1, 1}: 1.0,
    }
    obj2 := NewQuantumObject("Obj2", obj2Dist)
    
    world.AddQuantumObject(obj1)
    world.AddQuantumObject(obj2)
    
    // Первое взаимодействие — объекты коллапсируют
    world.MeasureInteraction(obj1, obj2)
    
    // Добавим новый объект для взаимодействия с Obj1
    obj3Dist := map[[2]int]float64{
        {1, 1}: 1.0,
    }
    obj3 := NewQuantumObject("Obj3", obj3Dist)
    world.AddQuantumObject(obj3)
    
    // Взаимодействие Obj1 и Obj3 — Obj1 уже коллапсирован
    world.MeasureInteraction(obj1, obj3)
    
    // Проверка состояния объектов
    fmt.Println(obj1)
    fmt.Println(obj2)
    fmt.Println(obj3)
}

```

**Ожидаемый результат:**

- После первого взаимодействия объекты `Obj1` и `Obj2` коллапсируют в координате (1,1).
- При взаимодействии `Obj1` и `Obj3`, `Obj1` уже коллапсирован и не изменяется.
- `Obj3` также коллапсирует в (1,1) при взаимодействии с `Obj1`.

```
<Obj1 collapsed at (1, 1)>
<Obj2 collapsed at (1, 1)>
<Obj3 collapsed at (1, 1)>
```

**Итоговый результат**
```
<Obj1 collapsed at (1, 1)>
<Obj2 collapsed at (1, 1)>
<Obj3 collapsed at (1, 1)>
```

### Обобщение результатов симуляций

Проведенные симуляции подтвердили следующие свойства модели:

1. **Нормировка распределений сохраняется** после взаимодействий и коллапсов.
2. **Взаимодействия зависят исключительно от совпадения координат**, независимо от расстояния между объектами.
3. **Система устойчива**, так как после коллапса объекты фиксируются в своих состояниях и не изменяются при последующих взаимодействиях.

Эти результаты соответствуют математическим утверждениям и поддерживают концепцию отсутствия фундаментального понятия расстояния и времени в модели.
